# 1 入口

## 1.1 获取源码

`Vue`的完整代码可从通过git+github获取：

```bash
git@github.com:vuejs/vue.git
```

## 1.2 分析打包命令

在我们平时所见到的项目中，打包命令都是声明在`package.json`的`script`字段中，`Vue`也不例外，打开源码中的`package.json`查看里面的`script`如下所示：

```json
"scripts": {
    "dev": "rollup -w -c scripts/config.js --environment TARGET:web-full-dev",
    "dev:cjs": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-cjs-dev",
    "dev:esm": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-esm",
    "dev:compiler": "rollup -w -c scripts/config.js --environment TARGET:web-compiler "
}
```

结合`Vue`官方文档**[对不同版构建版本的解释]([https://cn.vuejs.org/v2/guide/installation.html#%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A](https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释))**来看，可总结出以上命令的作用：

- web-full-dev: **完整版**,同时包含编译器和运行时的版本。

- web--runtime-cjs-dev: **[CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1)**：Vue提供CommonJS 版本用来配合老的打包工具比如 [Browserify](http://browserify.org/) 或 [webpack 1](https://webpack.github.io/)。这些打包工具的默认文件 (`pkg.main`) 是只包含运行时的 CommonJS 版本。(`vue.runtime.common.js`)。
- web-runtime-esm: **[ES Module](http://exploringjs.com/es6/ch_modules.html)**：从 2.6 开始 Vue 会提供两个 ES Modules (ESM) 构建文件：
  - 为打包工具提供的 ESM：为诸如 [webpack 2](https://webpack.js.org/) 或 [Rollup](https://rollupjs.org/) 提供的现代打包工具。ESM 格式被设计为可以被静态分析，所以打包工具可以利用这一点来进行“tree-shaking”并将用不到的代码排除出最终的包。为这些打包工具提供的默认文件 (`pkg.module`) 是只有运行时的 ES Module 构建 (`vue.runtime.esm.js`)。
  - 为浏览器提供的 ESM (2.6+)：用于在现代浏览器中通过 `<script type="module">` 直接导入。
- web-compiler：**编译器**：用来将模板字符串编译成为 JavaScript 渲染函数的代码。

我们选择从web-full-dev（完整版）切入。

## 1.3 分析打包配置

### 1.3.1 确定配置文件位置

结合上文，选择从web-full-dev（完整版）切入，即从以下打包命令出发：

```json
"dev": "rollup -w -c scripts/config.js --environment TARGET:web-full-dev"
```

在该命令中，使用了[Rollup](https://rollupjs.org/)打包工具，并通过-c命令行参数指定了配置文件`scripts/config.js`。

### 1.3.2 分析打包配置项

在`scripts/config.js`中，我们可以看到很多目标平台以及不同构建版本的配置，我们将焦点放在`web-full-dev`的配置项上：

```js
const builds = {
  // Runtime+compiler development build (Browser)
  'web-full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'), // 打包入口
    dest: resolve('dist/vue.js'), // 打包出口
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  }
  // ...
}
```

从上配置我们可以简单的分析出打包的入口和出口文件，打包的入口`entry`依赖于`resolve`函数的执行结果，`resolve`函数的入参为`web/entry-runtime-with-compiler.js`。

接下来我们分析`resolve`函数是如何运行的。

```javascript
// scripts/alias.js
const path = require('path')
const resolve = p => path.resolve(__dirname, '../', p)
module.exports = {
  web: resolve('src/platforms/web'),
  core: resolve('src/core')
}
// scripts/config.js
const aliases = require('./alias')
const resolve = p => {
  // p = 'web/entry-runtime-with-compiler.js'
  const base = p.split('/')[0] // base = ['web','entry-runtime-with-compiler.js']
  if (aliases[base]) {
    // aliases[base] = resolve('src/platforms/web')
    // p.slice(base.length + 1) = ['entry-runtime-with-compiler.js']
    return path.resolve(aliases[base], p.slice(base.length + 1))
  } else {
    return path.resolve(__dirname, '../', p)
  }
}
```

通过分析`resolve`的各个变量具体值，我们知道如下的映射关系：

```javascript
resolve('web/entry-runtime-with-compiler.js')
path.resolve(resolve('src/platforms/web'), ['entry-runtime-with-compiler.js'])
```

至此，我们找到了`web-full-dev`的打包入口文件路径`src/platforms/web/entry-runtime-with-compiler.js`。

