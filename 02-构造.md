# 2 构造与原型

在上一章中，我们找到了打包入口文件`src/platforms/web/entry-runtime-with-compiler.js`。

本章将基于该入口文件确定`Vue`构造函数的位置，并梳理`Vue`的目录结构以及构造函数。

## 2.1 确定构造函数位置

在打包入口文件`src/platforms/web/entry-runtime-with-compiler.js`顶部我们可以看到这行代码。

```javascript
import Vue from './runtime/index'
```

于是我们跟踪到`src/platforms/web/runtime/index.js`文件中，又发现了如下代码。

```javascript
import Vue from 'core/index'
```

相对路径往往很好跟踪，`core/index`则会让人产生疑惑，实际上`core`是预定义好的别名。

```javascript
// scripts/alias.js
const path = require('path')
const resolve = p => path.resolve(__dirname, '../', p)
module.exports = {
  web: resolve('src/platforms/web'),
  core: resolve('src/core') // core别名定义
}
```

现在我们找到了`src/core/index.js`中，在该文件顶部通过相对路径`./instance/index`引入`Vue`构造。

```javascript
import Vue from './instance/index'
```

于是我们终于找到`Vue`构造函数声明的地方`src/core/instance/index.js`

```javascript
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

## 2.2 构造与原型

### 2.2.1 构造函数

在分析构造函数之前，不妨让我们想想，我们是如何使用`Vue`的，假定从最简单的例子中切入。

```javascript
new Vue({
    el: '#app',
		data() {
        return {
			str: 'hello,world'
		}
	}
})
```

以上代码通过`new`关键字加上构造函数名创建`Vue`实例，并传递了一个对象作为参数，该对象有两个属性，`el`以及`data`。

回到源码当中，该对象作为构造函数的入参，构造函数将改入参定义为`options`。

```javascript
function Vue (options) {
  this._init(options)
}
```

紧接着通过调用`this._init(options)`初始化`Vue`实例。

这意味着传递给`Vue`构造函数的是一个配置项的集合，在创建时，`Vue`内部会通过我们指定的某些参数进行初始化，例如：`el`，`data` 。

```typescript
// src/core/instance/init.js
export function initMixin (Vue: Class<Component>) {
	Vue.prototype._init = function (options?: Object) {}
}
```

我们可以根据`Vue: Class<Component>`类型定义来找到`ComponentOptions`类型定义了解更多组件配置项。

`Vue`源码类型定义在根目录下`types`子目录中。

```typescript
// types/index.d.ts
export {
  Component, // Vue组件类型定义
  AsyncComponent,
  ComponentOptions,
  FunctionalComponentOptions,
  RenderContext,
  PropType,
  PropOptions,
  ComputedOptions,
  WatchHandler,
  WatchOptions,
  WatchOptionsWithHandler,
  DirectiveFunction,
  DirectiveOptions
} from "./options";

// types/options.d.ts
// 根据`Vue: Class<Component>`类型定义来找到`ComponentOptions`类型
export type Component<Data=DefaultData<never>, Methods=DefaultMethods<never>, Computed=DefaultComputed, Props=DefaultProps> =
  | typeof Vue
  | FunctionalComponentOptions<Props>
  | ComponentOptions<never, Data, Methods, Computed, Props> // 常见组件配置项类型定义

// 常见组件配置项类型定义
type DefaultData<V> =  object | ((this: V) => object);
type DefaultProps = Record<string, any>;
type DefaultMethods<V> =  { [key: string]: (this: V, ...args: any[]) => any };
type DefaultComputed = { [key: string]: any };
export interface ComponentOptions<
  V extends Vue,
  Data=DefaultData<V>,
  Methods=DefaultMethods<V>,
  Computed=DefaultComputed,
  PropsDef=PropsDefinition<DefaultProps>,
  Props=DefaultProps> {
  data?: Data;
  props?: PropsDef;
  propsData?: object;
  computed?: Accessors<Computed>;
  methods?: Methods;
  watch?: Record<string, WatchOptionsWithHandler<any> | WatchHandler<any> | string>;

  el?: Element | string;
  template?: string;
  // hack is for functional component type inference, should not be used in user code
  render?(createElement: CreateElement, hack: RenderContext<Props>): VNode;
  renderError?(createElement: CreateElement, err: Error): VNode;
  staticRenderFns?: ((createElement: CreateElement) => VNode)[];

  beforeCreate?(this: V): void;
  created?(): void;
  beforeDestroy?(): void;
  destroyed?(): void;
  beforeMount?(): void;
  mounted?(): void;
  beforeUpdate?(): void;
  updated?(): void;
  activated?(): void;
  deactivated?(): void;
  errorCaptured?(err: Error, vm: Vue, info: string): boolean | void;
  serverPrefetch?(this: V): Promise<void>;

  directives?: { [key: string]: DirectiveFunction | DirectiveOptions };
  components?: { [key: string]: Component<any, any, any, any> | AsyncComponent<any, any, any, any> };
  transitions?: { [key: string]: object };
  filters?: { [key: string]: Function };

  provide?: object | (() => object);
  inject?: InjectOptions;

  model?: {
    prop?: string;
    event?: string;
  };

  parent?: Vue;
  mixins?: (ComponentOptions<Vue> | typeof Vue)[];
  name?: string;
  // TODO: support properly inferred 'extends'
  extends?: ComponentOptions<Vue> | typeof Vue;
  delimiters?: [string, string];
  comments?: boolean;
  inheritAttrs?: boolean;
}

```

### 2.2.2 原型混入

在`Vue`的构造函数中，我们可以知道`Vue`并未在构造函数中定义实例的属性与方法，而是通过`this._init(options)`进行初始化，我们可以看到在构造函数定义底部有这么几行代码。

```javascript
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'

function Vue (options) {
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
```

即，在我们调用`Vue`构造函数之前，先定义好`Prototype`。

这些函数都是通过相对路径引入，通过查看这些函数我们发现，它们作用都是为`Vue`原型增加某一方面的功能，并从文件名可以很好的区分功能，以下为混入`Vue`原型中的函数。

```typescript
// src/core/instance/init.js
export function initMixin (Vue: Class<Component>) {
	Vue.prototype._init = function (options?: Object) {}
}

// src/core/instance/state.js
export function stateMixin (Vue: Class<Component>) {

    Object.defineProperty(Vue.prototype, '$data', dataDef)
    Object.defineProperty(Vue.prototype, '$props', propsDef)

    Vue.prototype.$set = set
    Vue.prototype.$delete = del

    Vue.prototype.$watch = function (
        expOrFn: string | Function,
        cb: any,
        options?: Object
    ): Function() {}
}

// src/core/instance/event.js
export function eventsMixin (Vue: Class<Component>) {

  Vue.prototype.$on = function (event: string | Array<string>, fn: Function): Component {}

  Vue.prototype.$once = function (event: string, fn: Function): Component {}

  Vue.prototype.$off = function (event?: string | Array<string>, fn?: Function): Component {}

  Vue.prototype.$emit = function (event: string): Component {}
}

// src/core/instance/lifecycle.js
export function lifecycleMixin (Vue: Class<Component>) {

  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {}

  Vue.prototype.$forceUpdate = function () {}

  Vue.prototype.$destroy = function () {}
}

// src/core/instance/render.js
export function renderMixin (Vue: Class<Component>) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype)

  Vue.prototype.$nextTick = function (fn: Function) {}

  Vue.prototype._render = function (): VNode {}
}

```

相信读者能够看到很多熟悉的函数签名，可根据实际的需求去了解对应的函数实现。

