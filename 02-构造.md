# 2 构造

在上一章中，我们找到了打包入口文件`src/platforms/web/entry-runtime-with-compiler.js`。

本章将基于该入口文件确定`Vue`构造函数的位置，并梳理`Vue`的目录结构以及构造函数。

## 2.1 确定构造函数位置

在打包入口文件`src/platforms/web/entry-runtime-with-compiler.js`顶部我们可以看到这行代码。

```javascript
import Vue from './runtime/index'
```

于是我们跟踪到`src/platforms/web/runtime/index.js`文件中，又发现了如下代码。

```javascript
import Vue from 'core/index'
```

相对路径往往很好跟踪，`core/index`则会让人产生疑惑，实际上`core`是预定义好的别名。

```javascript
// scripts/alias.js
const path = require('path')
const resolve = p => path.resolve(__dirname, '../', p)
module.exports = {
  web: resolve('src/platforms/web'),
  core: resolve('src/core')
}
```

现在我们找到了`src/core/index.js`中，在该文件顶部通过相对路径`./instance/index`引入`Vue`构造。

```javascript
import Vue from './instance/index'
```

于是我们终于找到`Vue`构造函数声明的地方`src/core/instance/index.js`

```javascript
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

## 2.2 构造与原型

### 2.2.1 构造函数

在分析构造函数之前，不妨让我们想想，我们是如何使用`Vue`的，假定从最简单的例子中切入。

```javascript
new Vue({
    el: '#app',
	data() {
        return {
			str: 'hello,world'
		}
	}
})
```

以上代码通过`new`关键字加上构造函数名创建`Vue`实例，并传递了一个对象作为参数，该对象有两个属性，`el`以及`data`。

回到源码当中，该对象作为构造函数的入参，构造函数将改入参定义为`options`。

```javascript
function Vue (options) {
  this._init(options)
}
```

紧接着通过调用`this._init(options)`初始化`Vue`实例。

这意味着传递给`Vue`构造函数的是一个配置项的集合，在创建时，`Vue`内部会通过我们指定的某些参数进行初始化，例如：`el`，`data` 。

### 2.2.2 原型混入

在`Vue`的构造函数中，我们可以知道`Vue`并未在构造函数中定义实例的属性与方法，而是通过`this._init(options)`进行初始化，我们可以看到在构造函数定义底部有这么几行代码。

```javascript
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'

function Vue (options) {
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
```

即，在我们调用`Vue`构造函数之前，先定义好`Prototype`。

这些函数都是通过相对路径引入，通过查看这些函数我们发现，它们作用都是为`Vue`原型增加某一方面的功能，并从文件名可以很好的区分功能，以下为混入`Vue`原型中的函数。



```javascript
// src/core/instance/init.js
export function initMixin (Vue: Class<Component>) {
	Vue.prototype._init = function (options?: Object) {}
}

// src/core/instance/state.js
export function stateMixin (Vue: Class<Component>) {

    Object.defineProperty(Vue.prototype, '$data', dataDef)
    Object.defineProperty(Vue.prototype, '$props', propsDef)

    Vue.prototype.$set = set
    Vue.prototype.$delete = del

    Vue.prototype.$watch = function (
    expOrFn: string | Function,
    cb: any,
    options?: Object
    ): Function() {}
}

// src/core/instance/event.js
export function eventsMixin (Vue: Class<Component>) {

  Vue.prototype.$on = function (event: string | Array<string>, fn: Function): Component {}

  Vue.prototype.$once = function (event: string, fn: Function): Component {}

  Vue.prototype.$off = function (event?: string | Array<string>, fn?: Function): Component {}

  Vue.prototype.$emit = function (event: string): Component {}
}

// src/core/instance/lifecycle.js
export function lifecycleMixin (Vue: Class<Component>) {

  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {}

  Vue.prototype.$forceUpdate = function () {}

  Vue.prototype.$destroy = function () {}
}

// src/core/instance/render.js
export function renderMixin (Vue: Class<Component>) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype)

  Vue.prototype.$nextTick = function (fn: Function) {}

  Vue.prototype._render = function (): VNode {}
}

```

相信读者能够看到很多熟悉的函数签名，可根据实际的需求去了解对应的函数实现。

