# 3 初始化

在上一章中，我们了解了构造与原型，并找到了初始化函数以及熟悉的配置项类型定义，`Vue`的构造函数执行的`_init`函数实际上就是对各种配置项进行初始化，本章将分步讲解此过程。

## 3.1 _init函数

`Vue.prototype._init `定义在`src/core/instance/init.js`中，代码如下：

```typescript
Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    // a flag to avoid this being observed
    vm._isVue = true
  
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
 
  	vm._renderProxy = vm
    // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
}
```

代码所实现功能明显，大体流程如下：

1. 设置响应式流程标记
2. 合并配置项
3. 初始化生命周期
4. 初始化监听事件
5. 初始化渲染函数
6. 初始化组件状态
8. 挂载至el节点

### 3.1.1 设置响应式流程标记

```javascript
// a flag to avoid this being observed
vm._isVue = true
```

该变量的作用主要在于标注该对象是`Vue实例`。

由于在后续的`initState`过程中会对组件`data`函数返回对象的属性走响应式流程，该标记可以防止`Vue实例`作为`data`返回对象属性走响应式流程，如下述案例所示：

```html
<div id="app1">
</div>
<div id="app2">
</div>
```

```javascript
 const app1 = new Vue({
   el: "#app1",
   data() {
     return {
     };
   },
 });
const app2 = new Vue({
  el: "#app2",
  data() {
    return {
      app1, // app1作为app2的data返回对象属性
    };
  },
});
```

以下为响应式流程部分代码：

```typescript
// src/core/observer/index.js
export function observe (value: any, asRootData: ?boolean): Observer | void {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue // 判断观察对象是否为Vue实例
  ) {
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}
```

### 3.1.2 合并配置项

```javascript
if (options && options._isComponent) { // 忽略该分支
  initInternalComponent(vm, options)
} else {
  // 合并配置项
  vm.$options = mergeOptions(
    resolveConstructorOptions(vm.constructor),
    options || {},
    vm
  )
}
```

忽略`options._isComponent`分支的原因是在大部分场景下，`options`选项是由开发者传入的，而`isComponent`变量并未在官方文档上进行说明，且源码目录`types/options.d.ts`的`ComponentOptions`类型也并未提及该变量，那么该变量可能是`Vue`在帮我们实例化组件时赋值的。

将关注点放回至合并配置项中。

```javascript
// 合并配置项
 vm.$options = mergeOptions(
   resolveConstructorOptions(vm.constructor),
   options || {},
   vm
 )
```

我们可以看到在调用`mergeOptions`函数参数之一为`resolveConstructorOptions(vm.constructor)`，代码如下：

```typescript
export function resolveConstructorOptions (Ctor: Class<Component>) {
  let options = Ctor.options // 获取构造函数配置项
  if (Ctor.super) { // 如果构造函数存在父类构造函数
    // 以父类构造函数进行递归，并获取已合并好的父构造对应的options
    const superOptions = resolveConstructorOptions(Ctor.super) 
    const cachedSuperOptions = Ctor.superOptions 
    if (superOptions !== cachedSuperOptions) { // 父配置项缓存控制
      Ctor.superOptions = superOptions
      // 合并最新的父构造options
      const modifiedOptions = resolveModifiedOptions(Ctor)
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions)
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) {
        options.components[options.name] = Ctor
      }
    }
  }
  return options
}
```

我们将关注点放在第3行代码上，即`if(Ctor.super)`，该分支在不使用`Vue.extend`创建的构造函数时并不会执行，这是由于`Ctor.super`变量赋值时机在`Vue.extend`函数执行时。

参考官方文档对`Vue.extend`解释：使用基础 `Vue` 构造器，创建一个“子类”。参数是一个包含组件选项的对象。

由于`Vue.extend`基于已有配置，创建全新的`Vue`构造函数，那么该构造可能被多次调用，所以上述代码第`7`行，即`if (superOptions !== cachedSuperOptions) `分支会对此进行缓存处理，并检查缓存有效性。

同时，`Vue.Component`是基于`Vue.extend`实现的，所以流程与`Vue.extend`相同，可查看源码中的`global-api`中对于`Vue.Component`的定义。

```typescript
// src/core/global-api/index.js
Vue.options._base = Vue // 定义_base

// src/core/global-api/assets.js
export function initAssetRegisters (Vue: GlobalAPI) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(type => {
    Vue[type] = function (
      id: string,
      definition: Function | Object
    ): Function | Object | void {
        if (type === 'component' && isPlainObject(definition)) { // 定义Vue.compoent
          definition.name = definition.name || id
          definition = this.options._base.extend(definition) // 使用Vue.extend
        }
        this.options[type + 's'][id] = definition
        return definition
      }
    }
  })
}
```

以下为`Vue.extend`相关实现代码：

```typescript
// src/core/global-api/extend.js
Vue.extend = function (extendOptions: Object): Function {
  const Super = this
  const Sub = function VueComponent (options) { // 当new Sub调用，Sub实例.Ctor.Super已赋值
    this._init(options)
  }
  Sub['super'] = Super // Sub实例.Ctor.Super赋值成功
  return Sub
}
```

基于以上结论，既然该函数为`Vue.extend`流程执行，因为我们只研究最简单情况下`new Vue(options)`的初始化流程，所以我们可以忽略该分支，忽略后代码如下：

```typescript
export function resolveConstructorOptions (Ctor: Class<Component>) {
  let options = Ctor.options // 获取构造函数配置项
  return options
}
```

接下来我们回到`mergeOptions`函数调用，在上述分析中得知`resolveConstructorOptions(vm.constructor)`其实就是`vm.constructor.options`，调用过程就是将`vm.constructor.options`与实例`options`进行合并。

```javascript
vm.$options = mergeOptions(
  // resolveConstructorOptions(vm.constructor),
  vm.constructor.options,
  options || {},
  vm
)
```

### 3.1.3 初始化生命周期

```typescript
export function initLifecycle (vm: Component) {
  const options = vm.$options

  let parent = options.parent
  if (parent && !options.abstract) { // vnode
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = {}

  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}
```

以上代码较为容易理解，作用是对实例部分属性进行预定义，特别的是第`5`行代码，即`if (parent && !options.abstract)`，该分支是假定当前实例作为其他组件的子组件时，通过循环查找非抽象的父组件，并将当前实例添加到父组件的`$children`属性中。

### 3.1.4 初始化监听事件

```javascript
export function initEvents (vm: Component) {
  vm._events = Object.create(null)
  vm._hasHookEvent = false
  // init parent attached events
  const listeners = vm.$options._parentListeners
  if (listeners) {
    updateComponentListeners(vm, listeners)
  }
}
```

从代码中可以看出，初始化监听事件主要处理存在父组件监听事件的情况。

`vm.$options._parentListeners`的赋值时机在**3.1.2 合并配置项**忽略分支`if (options && options._isComponent)`中的`initInternalComponent(vm, options)`函数。

实现代码如下：

```typescript
// src/core/instance/init.js
Vue.prototype._init = function (options?: Object) {
  if (options && options._isComponent) {
    initInternalComponent(vm, options)
  }else {
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }
}

export function initInternalComponent (vm: Component, options: InternalComponentOptions) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  // doing this because it's faster than dynamic enumeration.
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}

```

由此可见当`vm.$options._parentListeners`存在时，上述代码第3行`options && options._isComponent`必定为True，即当前实例作为其他组件的子组件时才会执行。

至于为何不用上述代码第6行`mergeOptions`进行选项合并，上述代码第16行源码英文注释也已经说明。

### 3.1.5 初始化渲染函数

```typescript
export function initRender (vm: Component) {
  vm._vnode = null // the root of the child tree
  vm._staticTrees = null // v-once cached trees
  const options = vm.$options
  const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree
  const renderContext = parentVnode && parentVnode.context
  vm.$slots = resolveSlots(options._renderChildren, renderContext)
  vm.$scopedSlots = emptyObject
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)

}
```

在初始化渲染函数中，`Vue`对某些变量进行的初始化赋值，其中较为重要的是`$slots`,`$scopedSlots`,`_c`,`$createElement`。

`$slots`,`$scopedSlots`用于实现插槽，不太熟悉的读者可通过官网**[插槽](https://cn.vuejs.org/v2/guide/components-slots.html)**学习相关概念。

简单来说插槽就是在当前组件留一个坑位，由父组件决定该坑位渲染什么内容。

`$slots`,`$scopedSlots`不同之处在于是否使用了插槽作用域`slot-scope`进行属性传递。

`_c`,`$createElement`内部调用了同一个函数`createElement`，查看注释可了解每个参数定义，差别在于最后一个参数`alwaysNormalize`的区别，这两个函数主要在生成的`render`函数中调用，同时我们也可以在组件内通过`this.$createElement`动态渲染组件。

`Normalize`是`Vue`内部的标准化流程，由于`Vue`兼容许多写法，但内部需要统一处理。

`createElement`涉及渲染流程，暂不对此深究，待后续分析。

### 3.1.6 初始化组件状态

```

```

