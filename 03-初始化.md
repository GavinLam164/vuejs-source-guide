# 3 初始化

在上一章中，我们了解了构造与原型，并找到了初始化函数以及熟悉的配置项类型定义，`Vue`的构造函数执行的`_init`函数实际上就是对各种配置项进行初始化，本章将分步讲解此过程。

## 3.1 _init函数

`Vue.prototype._init `定义在`src/core/instance/init.js`中，代码如下：

```typescript
Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    // a flag to avoid this being observed
    vm._isVue = true
  
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
 
  	vm._renderProxy = vm
    // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
}
```

代码所实现功能明显，大体流程如下：

1. 设置响应式流程标记
2. 合并配置项
3. 初始化生命周期
4. 初始化监听事件
5. 初始化渲染函数
6. 初始化组件状态
7. 挂载至el节点

### 3.1.1 设置响应式流程标记

```javascript
// a flag to avoid this being observed
vm._isVue = true
```

该变量的作用主要在于标注该对象是`Vue实例`。

由于在后续的`initState`过程中会对组件`data`函数返回对象的属性走响应式流程，该标记可以防止`Vue实例`作为`data`返回对象属性走响应式流程，如下述案例所示：

```html
<div id="app1">
</div>
<div id="app2">
</div>
```

```javascript
const app1 = new Vue({
  el: "#app1",
  data() {
    return {
    };
  },
});
const app2 = new Vue({
  el: "#app2",
  data() {
    return {
      app1, // app1作为app2的data返回对象属性
    };
  },
});
```

以下为响应式流程部分代码：

```typescript
// src/core/observer/index.js
export function observe (value: any, asRootData: ?boolean): Observer | void {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue // 判断观察对象是否为Vue实例,如果Vue实例则不创建对应的Observer
  ) {
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}
```

### 3.1.2 合并配置项

```javascript
if (options && options._isComponent) { // 忽略该分支
  initInternalComponent(vm, options)
} else {
  // 合并配置项
  vm.$options = mergeOptions(
    resolveConstructorOptions(vm.constructor),
    options || {},
    vm
  )
}
```

忽略`options._isComponent`分支的原因是在大部分场景下，`options`选项是由开发者传入的，而`isComponent`变量并未在官方文档上进行说明，且源码目录`types/options.d.ts`的`ComponentOptions`类型也并未提及该变量，那么该变量可能是`Vue`在帮我们实例化组件时赋值的。

将关注点放回至合并配置项中。

```javascript
// 合并配置项
 vm.$options = mergeOptions(
   resolveConstructorOptions(vm.constructor),
   options || {},
   vm
 )
```

我们可以看到在调用`mergeOptions`函数参数之一为`resolveConstructorOptions(vm.constructor)`，代码如下：

```typescript
export function resolveConstructorOptions (Ctor: Class<Component>) {
  let options = Ctor.options // 获取构造函数配置项
  if (Ctor.super) { // 如果构造函数存在父类构造函数
    // 以父类构造函数进行递归，并获取已合并好的父构造对应的options
    const superOptions = resolveConstructorOptions(Ctor.super) 
    const cachedSuperOptions = Ctor.superOptions 
    if (superOptions !== cachedSuperOptions) { // 父配置项缓存控制
      Ctor.superOptions = superOptions
      // 合并最新的父构造options
      const modifiedOptions = resolveModifiedOptions(Ctor)
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions)
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) {
        options.components[options.name] = Ctor
      }
    }
  }
  return options
}
```

我们将关注点放在第3行代码上，即`if(Ctor.super)`，该分支在不使用`Vue.extend`创建的构造函数时并不会执行，这是由于`Ctor.super`变量赋值时机在`Vue.extend`函数执行时。

参考官方文档对`Vue.extend`解释：使用基础 `Vue` 构造器，创建一个“子类”。参数是一个包含组件选项的对象。

由于`Vue.extend`基于已有配置，创建全新的`Vue`构造函数，那么该构造可能被多次调用，所以上述代码第`7`行，即`if (superOptions !== cachedSuperOptions) `分支会对此进行缓存处理，并检查缓存有效性。

同时，`Vue.Component`是基于`Vue.extend`实现的，所以流程与`Vue.extend`相同，可查看源码中的`global-api`中对于`Vue.Component`的定义。

```typescript
// src/core/global-api/index.js
Vue.options._base = Vue // 定义_base

// src/core/global-api/assets.js
export function initAssetRegisters (Vue: GlobalAPI) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(type => {
    Vue[type] = function (
      id: string,
      definition: Function | Object
    ): Function | Object | void {
        if (type === 'component' && isPlainObject(definition)) { // 定义Vue.compoent
          definition.name = definition.name || id
          definition = this.options._base.extend(definition) // 使用Vue.extend
        }
        this.options[type + 's'][id] = definition
        return definition
      }
    }
  })
}
```

以下为`Vue.extend`相关实现代码：

```typescript
// src/core/global-api/extend.js
Vue.extend = function (extendOptions: Object): Function {
  const Super = this
  const Sub = function VueComponent (options) { // 当new Sub调用，Sub实例.Ctor.Super已赋值
    this._init(options)
  }
  Sub['super'] = Super // Sub实例.Ctor.Super赋值成功
  return Sub
}
```

基于以上结论，既然该函数为`Vue.extend`流程执行，因为我们只研究最简单情况下`new Vue(options)`的初始化流程，所以我们可以忽略该分支，忽略后代码如下：

```typescript
export function resolveConstructorOptions (Ctor: Class<Component>) {
  let options = Ctor.options // 获取构造函数配置项
  return options
}
```

接下来我们回到`mergeOptions`函数调用，在上述分析中得知`resolveConstructorOptions(vm.constructor)`其实就是`vm.constructor.options`，调用过程就是将`vm.constructor.options`与实例`options`进行合并。

```javascript
vm.$options = mergeOptions(
  // resolveConstructorOptions(vm.constructor),
  vm.constructor.options,
  options || {},
  vm
)
```

以下为`mergeOptions`实现：

```typescript
export function mergeOptions (
  parent: Object,
  child: Object,
  vm?: Component
): Object {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child)
  }

  if (typeof child === 'function') {
    child = child.options
  }

  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm)
    }
    if (child.mixins) {
      for (let i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
      }
    }
  }

  const options = {}
  let key
  for (key in parent) {
    mergeField(key)
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key)
    }
  }
  function mergeField (key) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}
```

从上述代码第一个参数为`Vue构造函数options`，第二个参数为`Vue实例options`, 流程如下：

1. 代码第14行：标准化`Vue实例options`中的：`Props`,`Inject`,`Directives`
2. 代码第22行：根据注释理解，该分支通过`child._base`判断是否是`extends`和`mixins`的子`options`
   - 对`options`中的`extends`和 `mixins`进行递归选项合并
3. 代码第33行：合并`Vue构造函数options`与`Vue实例options`

以上流程中的关键代码在于`mergeField`函数实现，而该函数依赖于`strats`对象，`strats`对象各个属性赋值在`src/core/util/options.js`中，以下代码为常见选项的合并函数。

```typescript
// src/core/util/options.js
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal: ?Object,
  childVal: ?Object,
  vm?: Component,
  key: string
): ?Object {
  if (!parentVal) return childVal
  const ret = Object.create(null)
  extend(ret, parentVal) // 使用extend进行合并
  if (childVal) extend(ret, childVal)
  return ret
}
```

至于`extend`函数我们可以在`src/shared/utils.js`中找到，该方法实现就是简单的赋值操作，实现如下：

```typescript
// src/shared/utils.js
export function extend (to: Object, _from: ?Object): Object {
  for (const key in _from) {
    to[key] = _from[key]
  }
  return to
}
```

### 3.1.3 初始化生命周期

```typescript
export function initLifecycle (vm: Component) {
  const options = vm.$options

  let parent = options.parent
  if (parent && !options.abstract) { // abstract表明vnode抽象节点：如template/keep-alive以及没有template/render函数的vue利息
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = {}

  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}
```

以上代码较为容易理解，作用是对实例部分属性进行预定义，特别的是第`5`行代码，即`if (parent && !options.abstract)`，该分支是假定当前实例作为其他组件的子组件时，通过循环查找非抽象的父组件，并将当前实例添加到父组件的`$children`属性中。

### 3.1.4 初始化监听事件

```javascript
export function initEvents (vm: Component) {
  vm._events = Object.create(null)
  vm._hasHookEvent = false
  // init parent attached events
  const listeners = vm.$options._parentListeners
  if (listeners) {
    updateComponentListeners(vm, listeners)
  }
}
```

从代码中可以看出，初始化监听事件主要处理存在父组件监听事件的情况。

`vm.$options._parentListeners`的赋值时机在**3.1.2 合并配置项**忽略分支`if (options && options._isComponent)`中的`initInternalComponent(vm, options)`函数。

实现代码如下：

```typescript
// src/core/instance/init.js
Vue.prototype._init = function (options?: Object) {
  if (options && options._isComponent) { // 该分支作为子组件时执行
    initInternalComponent(vm, options)
  }else {
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }
}

export function initInternalComponent (vm: Component, options: InternalComponentOptions) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  // doing this because it's faster than dynamic enumeration.
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners // 赋值_parentListeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}

```

由此可见当`vm.$options._parentListeners`存在时，上述代码第3行`options && options._isComponent`必定为True，即当前实例作为其他组件的子组件时才会执行。

至于为何不用上述代码第6行`mergeOptions`进行选项合并，上述代码第16行源码英文注释也已经说明。

至于`updateComponentListeners(vm, listeners)`则是调用了`Vue实例`的`$on`与`$off`对`listeners`进行绑定和解绑的过程，关键代码如下：

```javascript
// src/core/instance/event.js
function add (event, fn) {
  target.$on(event, fn)
}

function remove (event, fn) {
  target.$off(event, fn)
}

export function updateComponentListeners (
  vm: Component,
  listeners: Object,
  oldListeners: ?Object
) {
  target = vm
  // 将add与remove作为第三个和第四个参数传入updateListeners
  updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm)
  target = undefined
}

// src/core/vdom/helpers/update-listeners.js
export function updateListeners (
  on: Object,
  oldOn: Object,
  add: Function,
  remove: Function,
  createOnceHandler: Function,
  vm: Component
) {
  let name, def, cur, old, event
  for (name in on) {
    def = cur = on[name]
    old = oldOn[name]
    event = normalizeEvent(name)
    if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm)
      }
      if (isTrue(event.once)) { // 实现once
        cur = on[name] = createOnceHandler(event.name, cur, event.capture)
      }
      // 调用add函数注册监听事件
      add(event.name, cur, event.capture, event.passive, event.params)
    } else if (cur !== old) {
      old.fns = cur
      on[name] = old
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name)
      // 调用remove删除监听事件
      remove(event.name, oldOn[name], event.capture)
    }
  }
}
```

### 3.1.5 初始化渲染函数

```typescript
export function initRender (vm: Component) {
  vm._vnode = null // the root of the child tree
  vm._staticTrees = null // v-once cached trees
  const options = vm.$options
  const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree
  const renderContext = parentVnode && parentVnode.context
  vm.$slots = resolveSlots(options._renderChildren, renderContext)
  vm.$scopedSlots = emptyObject
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)

}
```

在初始化渲染函数中，`Vue`对某些变量进行的初始化赋值，其中较为重要的是`$slots`,`$scopedSlots`,`_c`,`$createElement`。

`$slots`,`$scopedSlots`用于实现插槽，不太熟悉的读者可通过官网**[插槽](https://cn.vuejs.org/v2/guide/components-slots.html)**学习相关概念。

简单来说插槽就是在当前组件留一个坑位，由父组件决定该坑位渲染什么内容。

`$slots`,`$scopedSlots`不同之处在于是否使用了插槽作用域`slot-scope`进行属性传递。

`_c`,`$createElement`内部调用了同一个函数`createElement`，查看注释可了解每个参数定义，差别在于最后一个参数`alwaysNormalize`的区别，`Normalize`是`Vue`内部的标准化流程，由于`Vue`兼容许多写法，内部需要统一处理。

`_c`,`$createElement`主要在生成的`render`函数中调用，同时我们也可以在组件内通过`this.$createElement`动态渲染组件。

`createElement`涉及渲染流程，暂不对此深究，待后续分析。

### 3.1.6 初始化组件状态

```javascript
initInjections(vm) 
initState(vm)
initProvide(vm) 
```

流程中可以看出在进行`initState(vm)`的前后调用了`initInjections(vm) `和`initProvide(vm) `。

不熟悉`provide / inject`的读者可以参考官网[provide / inject](https://cn.vuejs.org/v2/api/#provide-inject)。

之所以`initInjections`在`initState`之前调用，是因为`Vue`提供了在`data/props`中使用`inject`声明属性的场景，例如官网案例：

```javascript
const Child = {
  inject: ['foo'], // 注入foo属性
  props: {
    myFoo: {
      type: String,
      default() {
        return this.foo // 使用注入属性foo作为当前组件myFoo的属性默认值
      }
    }
  },
  data () {
    return {
      bar: this.foo // 设置为data返回值属性
    }
  }
}
```

至于`initProvide`在`initState`之后调用，则是满足`provide`中可以使用`data/props`属性的场景，例如案例：

```javascript
const Parent = {
  props: ['age']
  provide() {
  	return {
  		parentName: this.name // 使用data中的name作为parentName
      parentAge: this.age// 使用props中的age作为parentAge
  	}
  },
  data () {
    return {
      name: 'Parent'
    }
  }
}
```

以下为`initInjections(vm)`实现。

```typescript
// src/ccore/instance/inject.js
export function initInjections (vm: Component) {
  const result = resolveInject(vm.$options.inject, vm)
  if (result) {
    toggleObserving(false)
    Object.keys(result).forEach(key => {
        defineReactive(vm, key, result[key])
    })
    toggleObserving(true)
  }
}
```

关键实现在`resolveInject(vm.$options.inject, vm)`,后续代码都是对该函数的返回值进行响应式流程，只不过不进行监听。

官网原话：`provide` 和 `inject` 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。

接着分析`resolveInject`实现。

```typescript
// src/ccore/instance/inject.js
export function resolveInject (inject: any, vm: Component): ?Object {
  if (inject) {
    const result = Object.create(null)
    const keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject)

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i] // key为inject属性名
      if (key === '__ob__') continue
      const provideKey = inject[key].from // from为provide的属性名
      let source = vm
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey]
          break
        }
        source = source.$parent // 查找父组件
      }
      if (!source) {
        if ('default' in inject[key]) {
          const provideDefault = inject[key].default
          result[key] = typeof provideDefault === 'function' // 若provide的属性为函数，则取调用结果
            ? provideDefault.call(vm)
            : provideDefault
        }
      }
    }
    return result
  }
}
```

从上述代码可以看出，`resolveInject`就是对`inject`对象中的各个属性进行向上查找，直至找到该属性的`provide`，进行赋值。

之所以区分`from`和`key`，是为了满足别名的`inject`属性使用别名的场景，例如：

```javascript
const Child = {
  inject: {
  	myFoo: 'foo'// 将foo属性设置为myFoo
  }
}
```

剩下`initProvide`过程，则只是做了个兼容函数写法的判断，不为函数则直接设置。

```javascript
export function initProvide (vm: Component) {
  const provide = vm.$options.provide
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide
  }
}
```

## 结语

源码代码中的代码常常兼容多种写法，所以会出现很多if分支，我们只需要关注主流程即可，防止在源码中迷失。

同时，在查看源代码产生迷惑时，可以结合官方文档以及源码注释，或者结合具体的使用场景进行分析。

上一节中的`initState(vm)`与主流程中最后的`挂载至el节点`流程涉及篇幅过大，将在后面的章节进行分析。