# 4 响应式系统

响应式系统是`Vue`的核心功能，也是`initState`中的关键实现，`Vue`通过结合依赖收集与发布订阅模式实现了依赖数据的关联与通知变更操作。

响应式系统的实现流程主要分为以下几个步骤：

1. 对数据对象中的基本类型属性进行`defineReactive`，并创建`dep`，在`set/get`时劫持数据并收集依赖。
2. 当调用数据对象中的`get`方法时，将`Watcher`添加至`defineReactive`中的`dep`队列中。
3. 当调用数据对象中的set方法时，将`defineReactive`的`dep`队列中的每个`Watcher`调用。

本章根据以上流程，结合源码，实现一个简单的响应式系统，帮助读者理解。

案例是综合案例，加入了`computed`以及`watch`，需要做一些额外的处理。

以下为案例代码。

```javascript
// options对象
const options = {
  data() {
    return {
      name: "张三",
      age: 18,
    };
  },
  computed: {
    introContent() {
      return `我叫${this.name}, 我今年${this.age}岁`;
    },
  },
  watch: {
    introContent(newVal) {
      console.log(newVal);
    },
  },
};
// 通用函数

// 构造函数
function Mvvm(options) {}

// 原型定义

// 测试案例
const person = new Mvvm(options);
person.name = "李四"; // 我叫李四, 我今年18岁
person.age = 24; // 我叫李四, 我今年24岁
```

## 4.1 初始化data

以下流程涉及`Object.defineProperty`的使用，不了解的读者可以参考：[MDN-Object.defineProperty()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)。

### 4.1.1 获取数据对象

从案例出发，`options.data`是一个函数，所以我们需要先调用该函数才能获取到`data`中的内容。

```javascript
// 构造函数
function Mvvm(options) {
  this.initData(options);
}
// 原型定义
Mvvm.prototype.initData = function (options) {
  const { data: dataFn } = options;
  this._data = dataFn();
};
```

### 4.1.2 _data访问代理

由于我们把`data`的返回值赋值到了实例的`_data`属性上，为了实现`this.name`访问到`this._data.name`，所以我们需要`_data`的每个属性通过`this`进行代理。

```javascript
// 通用函数
// target[key] => target[proxyProp][key]
function proxy(target, proxyProp, key) {
  const proxyObj = {
    set(newV) {
      target[proxyProp][key] = newV;
    },
    get() {
      return target[proxyProp][key];
    },
  };
  Object.defineProperty(target, key, proxyObj);
}
// 构造函数
function Mvvm(options) {
  this.initData(options);
}
// 原型定义
Mvvm.prototype.initData = function (options) {
  const { data: dataFn } = options;
  this._data = dataFn();
  for (let key in this._data) { // `_data`的每个属性通过`this`进行代理
    proxy(this, "_data", key);
  }
};
// 测试案例
const person = new Mvvm(options);
// 直接通过person.name访问person._data.name
console.log(person.name); // `张三`
```

### 4.1.3 响应式流程1：`defineReactive`

为了劫持`_data`属性的`set/get`，同样需要使用`Object.defineProperty`。

```javascript
// 通用函数
function defineReactive(target, key, val) {
  const proxyObj = {
    set(newV) {
      val = newV;
      console.log(`设置${key},值为${val}`);
    },
    get() {
      console.log(`获取${key},值为${val}`);
      return val;
    },
  };
  Object.defineProperty(target, key, proxyObj);
}
// 原型定义
Mvvm.prototype.initData = function (options) {
  const { data: dataFn } = options;
  this._data = dataFn();
  for (let key in this._data) {
    proxy(this, "_data", key);
    defineReactive(this._data, key, this._data[key]); // 劫持`_data`属性的`set/get`
  }
};
// 测试案例
const person = new Mvvm(options);
person.name = "李四"; // 触发name.set，打印`设置name,值为李四`
const name = person.name; // 触发name.get，打印`获取name,值为李四`。
console.log(name); // 打印`李四`
```

## 4.2 Watcher构造函数

我们知道`Vue`通过结合依赖收集与发布订阅模式实现了依赖数据的关联与通知变更操作。

那么我们先准备一个订阅者`Watcher`类，用于订阅属性变更。

我们先看看`Vue`的`computed/watch`是如何使用的。

```javascript
// options对象
const options = {
  data() {
    return {
      name: "张三",
      age: 18,
    };
  },
  computed: {
    introContent() {
      return `我叫${this.name}, 我今年${this.age}岁`;
    },
  },
  watch: {
    introContent(newVal) {
      console.log(newVal);
    },
  },
};
```

`computed/watch`函数名称分别对应：计算属性名/监听属性名。

实际上这两个功能的实现大体相似，区别仅在于：

- computed: 计算属性依赖于多个属性
- watch:函数执行依赖于某个属性

那么这两个函数体的功能显而易见，就是对于数据变更做某种相应的操作。

熟悉发布订阅模式的同学应该会联想到，这其实就是当被订阅者发布通知时，订阅者执行相关代码的场景。

结合上面案例解释：

```javascript
// options对象
const options = {
  data() {
    return {
      name: "张三",
      age: 18,
    };
  },
  computed: {
    introContent() { // 当name或者age数据变更时，调用该函数，获取最新的introContent属性
      return `我叫${this.name}, 我今年${this.age}岁`;
    },
  },
  watch: {
    introContent(newVal) {// 当introContent数据变更时，调用该函数，执行相关代码
      console.log(newVal);
    },
  },
};
```

综上所述，`Watcher`必须包含被通知时的函数。

其次，我们在`computed/watch`中还会使用`this`访问实例属性，需要通过`call`函数帮我们绑定一个`this`为当前实例，所以`Watcher`也必须包含`this`。

```javascript
// 构造函数
function Watcher(target, cb) {
  this.target = target
  this.cb = cb
}

// 原型定义
Watcher.prototype.update = function() {
  return this.cb.call(this.target)
}
```

### 4.3 响应式流程2：`Watcher`添加至`defineReactive`中的`dep`